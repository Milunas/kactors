package com.actors.generated

import org.jetbrains.kotlinx.lincheck.*
import org.jetbrains.kotlinx.lincheck.annotations.*
import org.jetbrains.kotlinx.lincheck.paramgen.*
import org.jetbrains.kotlinx.lincheck.strategy.managed.modelchecking.*
import org.jetbrains.kotlinx.lincheck.strategy.stress.*
import org.junit.jupiter.api.Test


/**
 * AUTO-GENERATED Lincheck test from TLA+ specification: ActorLifecycle
 *
 * Source: TlaFile(filePath=/Users/lukasz.milunas/Desktop/allegro/milunas/actors/src/main/tla/ActorLifecycle.tla, moduleName=ActorLifecycle)
 *
 * This test verifies that an implementation of the ActorLifecycle protocol
 * is linearizable with respect to the TLA+ specification's sequential semantics
 * AND that all 8 safety invariant(s) hold under every
 * explored interleaving.
 *
 * Invariants checked:
 *   - RestartBudgetRespected: \A a \in Actors : restartCount[a] <= MaxRestarts
 *   - StoppedNotAlive: \A a \in Actors : actorState[a] = "stopped" => a \notin alive
 *   - OnlyRunningProcess: \A a \in Actors : processed[a] > 0 => actorState[a] \in {"starting", "running", 
 *   - AliveConsistency: \A a \in Actors : a \in alive => actorState[a] /= "stopped"
 *   - PreStartBeforeProcess: \A a \in Actors : processed[a] > 0 => preStartDelivered[a] > 0
 *   - PostStopBounded: \A a \in Actors : postStopDelivered[a] <= restartCount[a] + 1
 *   - PreStartMatchesStarts: \A a \in Actors : preStartDelivered[a] <= restartCount[a] + 1
 *   - PreStartBeforePostStop: \A a \in Actors : postStopDelivered[a] <= preStartDelivered[a]
 *
 * Generated by tla2lincheck v0.1.0
 */

@Param(name = "a", gen = IntGen::class, conf = "1:5")

class ActorLifecycleLincheckTest {

    // ── Constants (from TLA+ CONSTANTS) ────────────────────────────
    private val Actors = (1..5).toSet()
    private val MaxRestarts = 5
    private val MaxMessages = 5

    // ── State fields (from TLA+ VARIABLES) ─────────────────────────

    private val preStartDelivered: MutableMap<Int, Int> = mutableMapOf()
    private val actorState: MutableMap<Int, Int> = mutableMapOf()
    private val processed: MutableMap<Int, Int> = mutableMapOf()
    private val alive: MutableSet<Int> = Actors.toMutableSet()
    private val restartCount: MutableMap<Int, Int> = mutableMapOf()
    private val postStopDelivered: MutableMap<Int, Int> = mutableMapOf()

    // ── Synchronization ────────────────────────────────────────────
    private val lockObj = Any()

    init {
        for (id in Actors) { preStartDelivered[id] = 0 }
        for (id in Actors) { actorState[id] = "created" }
        for (id in Actors) { processed[id] = 0 }
        for (id in Actors) { restartCount[id] = 0 }
        for (id in Actors) { postStopDelivered[id] = 0 }
    }


    // ── Invariant verification (from TLA+ safety invariants) ───────

    /**
     * Checks all TLA+ safety invariants after each operation.
     *
     * If any invariant is violated under ANY interleaving explored by
     * Lincheck's model checker, the test fails with the exact trace.
     */
    private fun checkInvariants() {
        // TLA+ invariant: RestartBudgetRespected
        check(Actors.all { a -> restartCount[a]!! <= MaxRestarts }) {
            "Invariant 'RestartBudgetRespected' violated"
        }
        // TLA+ invariant: StoppedNotAlive
        check(Actors.all { a -> (!(actorState[a]!! == "stopped")) || (a !in alive) }) {
            "Invariant 'StoppedNotAlive' violated"
        }
        // TLA+ invariant: OnlyRunningProcess
        check(Actors.all { a -> (!(processed[a]!! > 0)) || (actorState[a]!! in setOf("starting", "running", "stopping", "stopped", "restarting")) }) {
            "Invariant 'OnlyRunningProcess' violated"
        }
        // TLA+ invariant: AliveConsistency
        check(Actors.all { a -> (!(a in alive)) || (actorState[a]!! != "stopped") }) {
            "Invariant 'AliveConsistency' violated"
        }
        // TLA+ invariant: PreStartBeforeProcess
        check(Actors.all { a -> (!(processed[a]!! > 0)) || (preStartDelivered[a]!! > 0) }) {
            "Invariant 'PreStartBeforeProcess' violated"
        }
        // TLA+ invariant: PostStopBounded
        check(Actors.all { a -> postStopDelivered[a]!! <= restartCount[a]!! + 1 }) {
            "Invariant 'PostStopBounded' violated"
        }
        // TLA+ invariant: PreStartMatchesStarts
        check(Actors.all { a -> preStartDelivered[a]!! <= restartCount[a]!! + 1 }) {
            "Invariant 'PreStartMatchesStarts' violated"
        }
        // TLA+ invariant: PreStartBeforePostStop
        check(Actors.all { a -> postStopDelivered[a]!! <= preStartDelivered[a]!! }) {
            "Invariant 'PreStartBeforePostStop' violated"
        }
    }


    // ── Operations (from TLA+ actions) ─────────────────────────────

    /**
     * TLA+ action: Start
     * - Start: TLA+ action: Start
     */
    @Operation
    fun start(@Param(name = "a") a: Int): String = synchronized(lockObj) {
        if (actorState[a]!! == "created") {
            actorState[a] = "starting"
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: BecomeRunning
     * - BecomeRunning: TLA+ action: BecomeRunning
     */
    @Operation
    fun becomeRunning(@Param(name = "a") a: Int): String = synchronized(lockObj) {
        if (actorState[a]!! == "starting") {
            actorState[a] = "running"
            preStartDelivered[a] = preStartDelivered[a]!! + 1
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: ProcessMessage
     * - ProcessMessage: TLA+ action: ProcessMessage
     */
    @Operation
    fun processMessage(@Param(name = "a") a: Int): String = synchronized(lockObj) {
        if ((actorState[a]!! == "running") && (processed[a]!! < MaxMessages)) {
            processed[a] = processed[a]!! + 1
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: Fail
     * - Fail: TLA+ action: Fail
     */
    @Operation
    fun fail(@Param(name = "a") a: Int): String = synchronized(lockObj) {
        if ((actorState[a]!! == "running") && (restartCount[a]!! < MaxRestarts)) {
            actorState[a] = "restarting"
            restartCount[a] = restartCount[a]!! + 1
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: FailPermanent
     * - FailPermanent: TLA+ action: FailPermanent
     */
    @Operation
    fun failPermanent(@Param(name = "a") a: Int): String = synchronized(lockObj) {
        if ((actorState[a]!! == "running") && (restartCount[a]!! == MaxRestarts)) {
            actorState[a] = "stopping"
            alive.remove(a)
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: Restart
     * - Restart: TLA+ action: Restart
     */
    @Operation
    fun restart(@Param(name = "a") a: Int): String = synchronized(lockObj) {
        if (actorState[a]!! == "restarting") {
            actorState[a] = "starting"
            postStopDelivered[a] = postStopDelivered[a]!! + 1
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: GracefulStop
     * - GracefulStop: TLA+ action: GracefulStop
     */
    @Operation
    fun gracefulStop(@Param(name = "a") a: Int): String = synchronized(lockObj) {
        if (actorState[a]!! == "running") {
            actorState[a] = "stopping"
            alive.remove(a)
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: CompleteStopping
     * - CompleteStopping: TLA+ action: CompleteStopping
     */
    @Operation
    fun completeStopping(@Param(name = "a") a: Int): String = synchronized(lockObj) {
        if (actorState[a]!! == "stopping") {
            actorState[a] = "stopped"
            postStopDelivered[a] = postStopDelivered[a]!! + 1
            checkInvariants()
            return "ok"
        }
        return "noop"
    }



    // ── Lincheck test methods ──────────────────────────────────────

    /**
     * MODEL CHECKING MODE: Exhaustively explores ALL possible thread
     * interleavings.  If any interleaving produces a non-linearizable
     * result or violates an invariant, Lincheck reports the exact trace.
     */
    @Test
    fun modelCheckingTest() = ModelCheckingOptions()
        .threads(3)
        .actorsPerThread(2)
        .invocationsPerIteration(1000)
        .iterations(50)
        .checkObstructionFreedom(false)
        .actorsBefore(0)
        .actorsAfter(0)
        .check(this::class)

    /**
     * STRESS TEST MODE: Runs under real concurrent load.
     * Catches JVM-specific issues that model checking may miss.
     */
    @Test
    fun stressTest() = StressOptions()
        .threads(3)
        .actorsPerThread(2)
        .invocationsPerIteration(100)
        .iterations(25)
        .actorsBefore(0)
        .actorsAfter(0)
        .check(this::class)


}
