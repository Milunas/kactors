package com.actors.generated

import org.jetbrains.kotlinx.lincheck.*
import org.jetbrains.kotlinx.lincheck.annotations.*
import org.jetbrains.kotlinx.lincheck.paramgen.*
import org.jetbrains.kotlinx.lincheck.strategy.managed.modelchecking.*
import org.jetbrains.kotlinx.lincheck.strategy.stress.*
import org.junit.jupiter.api.Test


/**
 * AUTO-GENERATED Lincheck test from TLA+ specification: ActorTrace
 *
 * Source: TlaFile(filePath=/Users/lukasz.milunas/Desktop/allegro/milunas/actors/src/main/tla/ActorTrace.tla, moduleName=ActorTrace)
 *
 * This test verifies that an implementation of the ActorTrace protocol
 * is linearizable with respect to the TLA+ specification's sequential semantics
 * AND that all 7 safety invariant(s) hold under every
 * explored interleaving.
 *
 * Invariants checked:
 *   - BoundedTrace: \A a \in Actors : Len(trace[a]) <= MaxBufferSize
 *   - NonNegativeEventCount: \A a \in Actors : eventCount[a] >= 0
 *   - DeadActorTraceImmutable: \A a \in Actors : ~(actorAlive[a]) => eventCount[a] <= MaxEvents + 1
 *   - TraceLengthBounded: \A a \in Actors : Len(trace[a]) <= eventCount[a]
 *   - TraceLengthConsistency: \A a \in Actors : Len(trace[a]) <= MaxBufferSize
 *   - LamportClockMonotonic: \A a \in Actors : lamportClock[a] >= eventCount[a]
 *   - LamportClockNonNegative: \A a \in Actors : lamportClock[a] >= 0
 *
 * Generated by tla2lincheck v0.1.0
 */

@Param(name = "a", gen = IntGen::class, conf = "1:5")
@Param(name = "e", gen = IntGen::class, conf = "1:5")

class ActorTraceLincheckTest {

    // ── Constants (from TLA+ CONSTANTS) ────────────────────────────
    private val Actors = (1..5).toSet()
    private val MaxBufferSize = 5
    private val MaxEvents = 5

    // ── State fields (from TLA+ VARIABLES) ─────────────────────────

    private val lamportClock: MutableMap<Int, Int> = mutableMapOf()
    private val trace: MutableMap<Int, Int> = mutableMapOf()
    private val eventCount: MutableMap<Int, Int> = mutableMapOf()
    private val actorAlive: MutableMap<Int, Int> = mutableMapOf()
    private val lastSender: MutableMap<Int, Int> = mutableMapOf()

    // ── Synchronization ────────────────────────────────────────────
    private val lockObj = Any()

    init {
        for (id in Actors) { lamportClock[id] = 0 }
        for (id in Actors) { trace[id] = mutableListOf() }
        for (id in Actors) { eventCount[id] = 0 }
        for (id in Actors) { actorAlive[id] = 0 }
        for (id in Actors) { lastSender[id] = "none" }
    }


    // ── Invariant verification (from TLA+ safety invariants) ───────

    /**
     * Checks all TLA+ safety invariants after each operation.
     *
     * If any invariant is violated under ANY interleaving explored by
     * Lincheck's model checker, the test fails with the exact trace.
     */
    private fun checkInvariants() {
        // TLA+ invariant: BoundedTrace
        check(Actors.all { a -> Len(trace[a]!!) <= MaxBufferSize }) {
            "Invariant 'BoundedTrace' violated"
        }
        // TLA+ invariant: NonNegativeEventCount
        check(Actors.all { a -> eventCount[a]!! >= 0 }) {
            "Invariant 'NonNegativeEventCount' violated"
        }
        // TODO: TLA+ invariant 'DeadActorTraceImmutable' — complex expression, needs manual implementation
        // Raw TLA+: \A a \in Actors : ~(actorAlive[a]) => eventCount[a] <= MaxEvents + 1
        // TLA+ invariant: TraceLengthBounded
        check(Actors.all { a -> Len(trace[a]!!) <= eventCount[a]!! }) {
            "Invariant 'TraceLengthBounded' violated"
        }
        // TLA+ invariant: TraceLengthConsistency
        check(Actors.all { a -> Len(trace[a]!!) <= MaxBufferSize }) {
            "Invariant 'TraceLengthConsistency' violated"
        }
        // TLA+ invariant: LamportClockMonotonic
        check(Actors.all { a -> lamportClock[a]!! >= eventCount[a]!! }) {
            "Invariant 'LamportClockMonotonic' violated"
        }
        // TLA+ invariant: LamportClockNonNegative
        check(Actors.all { a -> lamportClock[a]!! >= 0 }) {
            "Invariant 'LamportClockNonNegative' violated"
        }
    }


    // ── Operations (from TLA+ actions) ─────────────────────────────

    /**
     * TLA+ action: RecordEvent
     * - RecordEvent: TLA+ action: RecordEvent
     */
    @Operation
    fun recordEvent(@Param(name = "a") a: Int, @Param(name = "e") e: Int): String = synchronized(lockObj) {
            trace[a] = IF Len(trace[a]!!) >= MaxBufferSize THEN Append(Tail(trace[a]!!), e) ELSE Append(trace[a]!!, e)
            eventCount[a] = eventCount[a]!! + 1
            lamportClock[a] = lamportClock[a]!! + 1
            checkInvariants()
            return "ok"
    }


    /**
     * TLA+ action: SendMessage
     * - SendMessage: TLA+ action: SendMessage
     */
    @Operation
    fun sendMessage(sender: Int, receiver: Int): String = synchronized(lockObj) {
            val senderNewClock = lamportClock[sender]!! + 1
            val receiverNewClock = IF lamportClock[receiver]!! >= senderNewClock THEN lamportClock[receiver]!! + 1 ELSE senderNewClock + 1
            trace[sender] = IF Len(trace[sender]!!) >= MaxBufferSize THEN Append(Tail(trace[sender]!!), "msg_received") ELSE Append(trace[sender]!!, "msg_received")
            eventCount[sender] = eventCount[sender]!! + 1
            lamportClock[sender] = senderNewClock
            lastSender[receiver] = sender
            checkInvariants()
            return "ok"
    }


    /**
     * TLA+ action: StopActor
     * - StopActor: TLA+ action: StopActor
     */
    @Operation
    fun stopActor(@Param(name = "a") a: Int): String = synchronized(lockObj) {
            actorAlive[a] = FALSE
            trace[a] = IF Len(trace[a]!!) >= MaxBufferSize THEN Append(Tail(trace[a]!!), "state_changed") ELSE Append(trace[a]!!, "state_changed")
            eventCount[a] = eventCount[a]!! + 1
            lamportClock[a] = lamportClock[a]!! + 1
            checkInvariants()
            return "ok"
    }


    /**
     * TLA+ action: AllDone
     * - AllDone: TLA+ action: AllDone
     */
    @Operation
    fun allDone(): String = synchronized(lockObj) {
            checkInvariants()
            return "ok"
    }



    // ── Lincheck test methods ──────────────────────────────────────

    /**
     * MODEL CHECKING MODE: Exhaustively explores ALL possible thread
     * interleavings.  If any interleaving produces a non-linearizable
     * result or violates an invariant, Lincheck reports the exact trace.
     */
    @Test
    fun modelCheckingTest() = ModelCheckingOptions()
        .threads(3)
        .actorsPerThread(2)
        .invocationsPerIteration(1000)
        .iterations(50)
        .checkObstructionFreedom(false)
        .actorsBefore(0)
        .actorsAfter(0)
        .check(this::class)

    /**
     * STRESS TEST MODE: Runs under real concurrent load.
     * Catches JVM-specific issues that model checking may miss.
     */
    @Test
    fun stressTest() = StressOptions()
        .threads(3)
        .actorsPerThread(2)
        .invocationsPerIteration(100)
        .iterations(25)
        .actorsBefore(0)
        .actorsAfter(0)
        .check(this::class)


}
