package com.actors.generated

import org.jetbrains.kotlinx.lincheck.*
import org.jetbrains.kotlinx.lincheck.annotations.*
import org.jetbrains.kotlinx.lincheck.paramgen.*
import org.jetbrains.kotlinx.lincheck.strategy.managed.modelchecking.*
import org.jetbrains.kotlinx.lincheck.strategy.stress.*
import org.junit.jupiter.api.Test


/**
 * AUTO-GENERATED Lincheck test from TLA+ specification: ActorHierarchy
 *
 * Source: TlaFile(filePath=/Users/lukasz.milunas/Desktop/allegro/milunas/actors/src/main/tla/ActorHierarchy.tla, moduleName=ActorHierarchy)
 *
 * This test verifies that an implementation of the ActorHierarchy protocol
 * is linearizable with respect to the TLA+ specification's sequential semantics
 * AND that all 6 safety invariant(s) hold under every
 * explored interleaving.
 *
 * Invariants checked:
 *   - ChildParentConsistency: \A p \in Actors : \A c \in children[p] : parent[c] = p
 *   - NoCycles: \A a \in Actors : parent[a] /= a
 *   - AliveChildHasLiveParent: \A a \in Actors : \land(state[a] \in {"alive", "stopping"}, parent[a] /= None) =
 *   - StoppedHasNoChildren: \A a \in Actors : state[a] = "stopped" => children[a] = {}
 *   - UnspawnedIsClean: \A a \in Actors : state[a] = "unspawned" => \land(parent[a] = None, children[a] 
 *   - ChildrenAreSpawned: \A p \in Actors : \A c \in children[p] : state[c] /= "unspawned"
 *
 * Generated by tla2lincheck v0.1.0
 */

@Param(name = "p", gen = IntGen::class, conf = "1:5")
@Param(name = "c", gen = IntGen::class, conf = "1:5")
@Param(name = "a", gen = IntGen::class, conf = "1:5")

class ActorHierarchyLincheckTest {

    // ── Constants (from TLA+ CONSTANTS) ────────────────────────────
    private val Actors = (1..5).toSet()
    private val None = 5
    private val Root = 5

    // ── State fields (from TLA+ VARIABLES) ─────────────────────────

    private val state: MutableMap<Int, Int> = mutableMapOf()
    private val children: MutableMap<Int, MutableSet<Int>> = mutableMapOf()
    private val parent: MutableMap<Int, Int> = mutableMapOf()

    // ── Synchronization ────────────────────────────────────────────
    private val lockObj = Any()

    init {
        for (id in Actors) { state[id] = 0 }
        for (id in Actors) { children[id] = mutableSetOf<Int>() }
        for (id in Actors) { parent[id] = 0 }
    }


    // ── Invariant verification (from TLA+ safety invariants) ───────

    /**
     * Checks all TLA+ safety invariants after each operation.
     *
     * If any invariant is violated under ANY interleaving explored by
     * Lincheck's model checker, the test fails with the exact trace.
     */
    private fun checkInvariants() {
        // TLA+ invariant: ChildParentConsistency
        check(Actors.all { p -> children[p]!!.all { c -> parent[c]!! == p } }) {
            "Invariant 'ChildParentConsistency' violated"
        }
        // TLA+ invariant: NoCycles
        check(Actors.all { a -> parent[a]!! != a }) {
            "Invariant 'NoCycles' violated"
        }
        // TODO: TLA+ invariant 'AliveChildHasLiveParent' — complex expression, needs manual implementation
        // Raw TLA+: \A a \in Actors : \land(state[a] \in {"alive", "stopping"}, parent[a] /= None) => state[parent[a]] \in {"alive", "stopping"}
        // TLA+ invariant: StoppedHasNoChildren
        check(Actors.all { a -> (!(state[a]!! == "stopped")) || (children[a]!! == setOf()) }) {
            "Invariant 'StoppedHasNoChildren' violated"
        }
        // TODO: TLA+ invariant 'UnspawnedIsClean' — complex expression, needs manual implementation
        // Raw TLA+: \A a \in Actors : state[a] = "unspawned" => \land(parent[a] = None, children[a] = {})
        // TLA+ invariant: ChildrenAreSpawned
        check(Actors.all { p -> children[p]!!.all { c -> state[c]!! != "unspawned" } }) {
            "Invariant 'ChildrenAreSpawned' violated"
        }
    }


    // ── Operations (from TLA+ actions) ─────────────────────────────

    /**
     * TLA+ action: SpawnChild
     * - SpawnChild: TLA+ action: SpawnChild
     */
    @Operation
    fun spawnChild(@Param(name = "p") p: Int, @Param(name = "c") c: Int): String = synchronized(lockObj) {
        if (((p != c) && (state[p]!! == "alive")) && (state[c]!! == "unspawned")) {
            state[c] = "alive"
            parent[c] = p
            children[p] = children[p]!!.add(c)
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: InitiateStop
     * - InitiateStop: TLA+ action: InitiateStop
     */
    @Operation
    fun initiateStop(@Param(name = "a") a: Int): String = synchronized(lockObj) {
        if (state[a]!! == "alive") {
            state[a] = "stopping"
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: CascadeStop
     * - CascadeStop: TLA+ action: CascadeStop
     */
    @Operation
    fun cascadeStop(@Param(name = "p") p: Int, @Param(name = "c") c: Int): String = synchronized(lockObj) {
        if (((state[p]!! == "stopping") && (c in children[p]!!)) && (state[c]!! == "alive")) {
            state[c] = "stopping"
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: CompleteStop
     * - CompleteStop: TLA+ action: CompleteStop
     */
    @Operation
    fun completeStop(@Param(name = "a") a: Int): String = synchronized(lockObj) {
        if ((state[a]!! == "stopping") && (children[a]!!.all { c -> state[c]!! == "stopped" })) {
            state[a] = "stopped"
            children[a] = {}
            checkInvariants()
            return "ok"
        }
        return "noop"
    }



    // ── Lincheck test methods ──────────────────────────────────────

    /**
     * MODEL CHECKING MODE: Exhaustively explores ALL possible thread
     * interleavings.  If any interleaving produces a non-linearizable
     * result or violates an invariant, Lincheck reports the exact trace.
     */
    @Test
    fun modelCheckingTest() = ModelCheckingOptions()
        .threads(3)
        .actorsPerThread(2)
        .invocationsPerIteration(1000)
        .iterations(50)
        .checkObstructionFreedom(false)
        .actorsBefore(0)
        .actorsAfter(0)
        .check(this::class)

    /**
     * STRESS TEST MODE: Runs under real concurrent load.
     * Catches JVM-specific issues that model checking may miss.
     */
    @Test
    fun stressTest() = StressOptions()
        .threads(3)
        .actorsPerThread(2)
        .invocationsPerIteration(100)
        .iterations(25)
        .actorsBefore(0)
        .actorsAfter(0)
        .check(this::class)


}
