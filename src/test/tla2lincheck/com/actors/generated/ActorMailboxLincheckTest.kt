package com.actors.generated

import org.jetbrains.kotlinx.lincheck.*
import org.jetbrains.kotlinx.lincheck.annotations.*
import org.jetbrains.kotlinx.lincheck.paramgen.*
import org.jetbrains.kotlinx.lincheck.strategy.managed.modelchecking.*
import org.jetbrains.kotlinx.lincheck.strategy.stress.*
import org.junit.jupiter.api.Test


/**
 * AUTO-GENERATED Lincheck test from TLA+ specification: ActorMailbox
 *
 * Source: TlaFile(filePath=/Users/lukasz.milunas/Desktop/allegro/milunas/actors/src/main/tla/ActorMailbox.tla, moduleName=ActorMailbox)
 *
 * This test verifies that an implementation of the ActorMailbox protocol
 * is linearizable with respect to the TLA+ specification's sequential semantics
 * AND that all 4 safety invariant(s) hold under every
 * explored interleaving.
 *
 * Invariants checked:
 *   - BoundedCapacity: Len(mailbox) <= Capacity
 *   - NoPhantomMessages: recvCount <= Len(mailbox) + recvCount
 *   - MessageConservation: LET totalSent ==
 *   - NonNegativeLength: Len(mailbox) >= 0
 *
 * Liveness properties (NOT checked — require TLC model checking):
 *   - Init: /\ mailbox = <<>>
 *   - Spec: Init /\ [][Next]_vars
 *
 * Generated by tla2lincheck v0.1.0
 */

@Param(name = "s", gen = IntGen::class, conf = "1:5")
@Param(name = "msg", gen = IntGen::class, conf = "1:5")

class ActorMailboxLincheckTest {

    // ── Constants (from TLA+ CONSTANTS) ────────────────────────────
    private val Senders = (1..5).toSet()
    private val Capacity = 5
    private val MaxMessages = 5

    // ── State fields (from TLA+ VARIABLES) ─────────────────────────

    private val mailbox: MutableList<Any> = mutableListOf()
    private val sendCount: MutableMap<Int, Int> = mutableMapOf()
    private var recvCount: Int = 0
    private var lastReceived: Int = 0

    // ── Synchronization ────────────────────────────────────────────
    private val lockObj = Any()

    init {
        for (id in Senders) { sendCount[id] = 0 }
    }


    // ── Invariant verification (from TLA+ safety invariants) ───────

    /**
     * Checks all TLA+ safety invariants after each operation.
     *
     * If any invariant is violated under ANY interleaving explored by
     * Lincheck's model checker, the test fails with the exact trace.
     */
    private fun checkInvariants() {
        // TLA+ invariant: BoundedCapacity
        check(mailbox.size <= Capacity) {
            "Invariant 'BoundedCapacity' violated"
        }
        // TLA+ invariant: NoPhantomMessages
        check(recvCount <= mailbox.size + recvCount) {
            "Invariant 'NoPhantomMessages' violated"
        }
        // TODO: TLA+ invariant 'MessageConservation' — complex expression, needs manual implementation
        // Raw TLA+: LET totalSent ==
        // TLA+ invariant: NonNegativeLength
        check(mailbox.size >= 0) {
            "Invariant 'NonNegativeLength' violated"
        }
    }


    // ── Operations (from TLA+ actions) ─────────────────────────────

    /**
     * TLA+ action: Send
     * - Send: TLA+ action: Send
     */
    @Operation
    fun send(@Param(name = "s") s: Int, @Param(name = "msg") msg: Int): String = synchronized(lockObj) {
        if ((mailbox.size < Capacity) && (sendCount[s]!! < MaxMessages)) {
            mailbox.add(msg)
            sendCount[s] = sendCount[s]!! + 1
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: TrySendFull
     * - TrySendFull: TLA+ action: TrySendFull
     */
    @Operation
    fun trySendFull(@Param(name = "s") s: Int): String = synchronized(lockObj) {
        if (mailbox.size == Capacity) {
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: Receive
     * - Receive: TLA+ action: Receive
     */
    @Operation
    fun receive(): String = synchronized(lockObj) {
        if (mailbox.size > 0) {
            mailbox.first()
            mailbox.removeFirst()
            recvCount += 1
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: TryReceiveEmpty
     * - TryReceiveEmpty: TLA+ action: TryReceiveEmpty
     */
    @Operation
    fun tryReceiveEmpty(): String = synchronized(lockObj) {
        if (mailbox.size == 0) {
            checkInvariants()
            return "ok"
        }
        return "noop"
    }



    // ── Lincheck test methods ──────────────────────────────────────

    /**
     * MODEL CHECKING MODE: Exhaustively explores ALL possible thread
     * interleavings.  If any interleaving produces a non-linearizable
     * result or violates an invariant, Lincheck reports the exact trace.
     */
    @Test
    fun modelCheckingTest() = ModelCheckingOptions()
        .threads(3)
        .actorsPerThread(2)
        .invocationsPerIteration(1000)
        .iterations(50)
        .checkObstructionFreedom(false)
        .actorsBefore(0)
        .actorsAfter(0)
        .check(this::class)

    /**
     * STRESS TEST MODE: Runs under real concurrent load.
     * Catches JVM-specific issues that model checking may miss.
     */
    @Test
    fun stressTest() = StressOptions()
        .threads(3)
        .actorsPerThread(2)
        .invocationsPerIteration(100)
        .iterations(25)
        .actorsBefore(0)
        .actorsAfter(0)
        .check(this::class)


}
