package com.actors.generated

import org.jetbrains.kotlinx.lincheck.*
import org.jetbrains.kotlinx.lincheck.annotations.*
import org.jetbrains.kotlinx.lincheck.paramgen.*
import org.jetbrains.kotlinx.lincheck.strategy.managed.modelchecking.*
import org.jetbrains.kotlinx.lincheck.strategy.stress.*
import org.junit.jupiter.api.Test


/**
 * AUTO-GENERATED Lincheck test from TLA+ specification: RequestReply
 *
 * Source: TlaFile(filePath=/Users/lukasz.milunas/Desktop/allegro/milunas/actors/src/main/tla/RequestReply.tla, moduleName=RequestReply)
 *
 * This test verifies that an implementation of the RequestReply protocol
 * is linearizable with respect to the TLA+ specification's sequential semantics
 * AND that all 4 safety invariant(s) hold under every
 * explored interleaving.
 *
 * Invariants checked:
 *   - MutualExclusion: \A c \in Clients, rid \in 1..MaxPending : Cardinality({x \in {"pending", "replie
 *   - NoReplyAfterTimeout: \A c \in Clients : replies[c] \cap timedOut[c] = {}
 *   - NoPhantomReplies: \A c \in Clients : Cardinality(replies[c] \cup timedOut[c]) <= nextRequestId[c] 
 *   - BoundedPending: \A c \in Clients : Cardinality(pendingRequests[c]) <= MaxPending
 *
 * Generated by tla2lincheck v0.1.0
 */

@Param(name = "c", gen = IntGen::class, conf = "1:5")
@Param(name = "rid", gen = IntGen::class, conf = "1:5")

class RequestReplyLincheckTest {

    // ── Constants (from TLA+ CONSTANTS) ────────────────────────────
    private val MaxPending = 5
    private val Clients = (1..5).toSet()

    // ── State fields (from TLA+ VARIABLES) ─────────────────────────

    private val nextRequestId: MutableMap<Int, Int> = mutableMapOf()
    private val timedOut: MutableMap<Int, MutableSet<Int>> = mutableMapOf()
    private val replies: MutableMap<Int, MutableSet<Int>> = mutableMapOf()
    private val serverQueue: MutableList<Any> = mutableListOf()
    private val pendingRequests: MutableMap<Int, MutableSet<Int>> = mutableMapOf()

    // ── Synchronization ────────────────────────────────────────────
    private val lockObj = Any()

    init {
        for (id in Clients) { nextRequestId[id] = 1 }
        for (id in Clients) { timedOut[id] = mutableSetOf<Int>() }
        for (id in Clients) { replies[id] = mutableSetOf<Int>() }
        for (id in Clients) { pendingRequests[id] = mutableSetOf<Int>() }
    }


    // ── Invariant verification (from TLA+ safety invariants) ───────

    /**
     * Checks all TLA+ safety invariants after each operation.
     *
     * If any invariant is violated under ANY interleaving explored by
     * Lincheck's model checker, the test fails with the exact trace.
     */
    private fun checkInvariants() {
        // TLA+ invariant: MutualExclusion
        check(Clients.all { c -> 1..MaxPending.all { rid -> {x \in {"pending", "replied", "timedOut"} : \land(x = "pending", rid \in pendingRequests[c]!!.size \/ \land(x = "replied", rid \in replies[c]!!) \/ \land(x = "timedOut", rid \in timedOut[c]!!)}) <= 1 } }) {
            "Invariant 'MutualExclusion' violated"
        }
        // TLA+ invariant: NoReplyAfterTimeout
        check(Clients.all { c -> replies[c]!! intersect timedOut[c]!! == setOf() }) {
            "Invariant 'NoReplyAfterTimeout' violated"
        }
        // TLA+ invariant: NoPhantomReplies
        check(Clients.all { c -> replies[c]!! union timedOut[c]!!.size <= nextRequestId[c]!! - 1 }) {
            "Invariant 'NoPhantomReplies' violated"
        }
        // TLA+ invariant: BoundedPending
        check(Clients.all { c -> pendingRequests[c]!!.size <= MaxPending }) {
            "Invariant 'BoundedPending' violated"
        }
    }


    // ── Operations (from TLA+ actions) ─────────────────────────────

    /**
     * TLA+ action: SendRequest
     * - SendRequest: TLA+ action: SendRequest
     */
    @Operation
    fun sendRequest(@Param(name = "c") c: Int): String = synchronized(lockObj) {
        if (nextRequestId[c]!! <= MaxPending) {
            val rid = nextRequestId[c]!!
            pendingRequests[c] = pendingRequests[c]!!.add(rid)
            serverQueue.add(listOf(c, rid))
            nextRequestId[c] = nextRequestId[c]!! + 1
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: ProcessRequest
     * - ProcessRequest: TLA+ action: ProcessRequest
     */
    @Operation
    fun processRequest(): String = synchronized(lockObj) {
        if (serverQueue.size > 0) {
            val req = serverQueue.first()
            val client = req[1]!!
            val rid = req[2]!!
            serverQueue.removeFirst()
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: DeliverReply
     * - DeliverReply: TLA+ action: DeliverReply
     */
    @Operation
    fun deliverReply(@Param(name = "c") c: Int, @Param(name = "rid") rid: Int): String = synchronized(lockObj) {
        if ((rid in pendingRequests[c]!!) && (rid !in timedOut[c]!!)) {
            pendingRequests[c] = pendingRequests[c]!!.remove(rid)
            replies[c] = replies[c]!!.add(rid)
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: Timeout
     * - Timeout: TLA+ action: Timeout
     */
    @Operation
    fun timeout(@Param(name = "c") c: Int, @Param(name = "rid") rid: Int): String = synchronized(lockObj) {
        if ((rid in pendingRequests[c]!!) && (rid !in replies[c]!!)) {
            pendingRequests[c] = pendingRequests[c]!!.remove(rid)
            timedOut[c] = timedOut[c]!!.add(rid)
            checkInvariants()
            return "ok"
        }
        return "noop"
    }



    // ── Lincheck test methods ──────────────────────────────────────

    /**
     * MODEL CHECKING MODE: Exhaustively explores ALL possible thread
     * interleavings.  If any interleaving produces a non-linearizable
     * result or violates an invariant, Lincheck reports the exact trace.
     */
    @Test
    fun modelCheckingTest() = ModelCheckingOptions()
        .threads(3)
        .actorsPerThread(2)
        .invocationsPerIteration(1000)
        .iterations(50)
        .checkObstructionFreedom(false)
        .actorsBefore(0)
        .actorsAfter(0)
        .check(this::class)

    /**
     * STRESS TEST MODE: Runs under real concurrent load.
     * Catches JVM-specific issues that model checking may miss.
     */
    @Test
    fun stressTest() = StressOptions()
        .threads(3)
        .actorsPerThread(2)
        .invocationsPerIteration(100)
        .iterations(25)
        .actorsBefore(0)
        .actorsAfter(0)
        .check(this::class)


}
