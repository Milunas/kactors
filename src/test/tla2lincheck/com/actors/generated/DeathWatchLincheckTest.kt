package com.actors.generated

import org.jetbrains.kotlinx.lincheck.*
import org.jetbrains.kotlinx.lincheck.annotations.*
import org.jetbrains.kotlinx.lincheck.paramgen.*
import org.jetbrains.kotlinx.lincheck.strategy.managed.modelchecking.*
import org.jetbrains.kotlinx.lincheck.strategy.stress.*
import org.junit.jupiter.api.Test


/**
 * AUTO-GENERATED Lincheck test from TLA+ specification: DeathWatch
 *
 * Source: TlaFile(filePath=/Users/lukasz.milunas/Desktop/allegro/milunas/actors/src/main/tla/DeathWatch.tla, moduleName=DeathWatch)
 *
 * This test verifies that an implementation of the DeathWatch protocol
 * is linearizable with respect to the TLA+ specification's sequential semantics
 * AND that all 6 safety invariant(s) hold under every
 * explored interleaving.
 *
 * Invariants checked:
 *   - NoPhantomTerminated: \A w \in Actors : \A t \in terminated[w] : t \notin alive
 *   - NoSelfWatch: \A a \in Actors : a \notin watching[a]
 *   - AliveNotTerminatedByAlive: \A w \in alive : \A t \in alive : t \notin terminated[w]
 *   - WatchSymmetryAlive: \A w \in alive : \A t \in watching[w] : t \in alive => w \in watchers[t]
 *   - TerminatedBounded: \A w \in Actors : terminated[w] \subseteq Actors
 *   - DeadNotWatching: \A a \in Actors : a \notin alive => watching[a] = {}
 *
 * Generated by tla2lincheck v0.1.0
 */

@Param(name = "w", gen = IntGen::class, conf = "1:5")
@Param(name = "a", gen = IntGen::class, conf = "1:5")

class DeathWatchLincheckTest {

    // ── Constants (from TLA+ CONSTANTS) ────────────────────────────
    private val Actors = (1..5).toSet()

    // ── State fields (from TLA+ VARIABLES) ─────────────────────────

    private val watching: MutableMap<Int, MutableSet<Int>> = mutableMapOf()
    private val alive: MutableSet<Int> = Actors.toMutableSet()
    private val watchers: MutableMap<Int, MutableSet<Int>> = mutableMapOf()
    private val terminated: MutableMap<Int, MutableSet<Int>> = mutableMapOf()

    // ── Synchronization ────────────────────────────────────────────
    private val lockObj = Any()

    init {
        for (id in Actors) { watching[id] = mutableSetOf<Int>() }
        for (id in Actors) { watchers[id] = mutableSetOf<Int>() }
        for (id in Actors) { terminated[id] = mutableSetOf<Int>() }
    }


    // ── Invariant verification (from TLA+ safety invariants) ───────

    /**
     * Checks all TLA+ safety invariants after each operation.
     *
     * If any invariant is violated under ANY interleaving explored by
     * Lincheck's model checker, the test fails with the exact trace.
     */
    private fun checkInvariants() {
        // TLA+ invariant: NoPhantomTerminated
        check(Actors.all { w -> terminated[w]!!.all { t -> t !in alive } }) {
            "Invariant 'NoPhantomTerminated' violated"
        }
        // TLA+ invariant: NoSelfWatch
        check(Actors.all { a -> a !in watching[a]!! }) {
            "Invariant 'NoSelfWatch' violated"
        }
        // TLA+ invariant: AliveNotTerminatedByAlive
        check(alive.all { w -> alive.all { t -> t !in terminated[w]!! } }) {
            "Invariant 'AliveNotTerminatedByAlive' violated"
        }
        // TLA+ invariant: WatchSymmetryAlive
        check(alive.all { w -> watching[w]!!.all { t -> (!(t in alive)) || (w in watchers[t]!!) } }) {
            "Invariant 'WatchSymmetryAlive' violated"
        }
        // TLA+ invariant: TerminatedBounded
        check(Actors.all { w -> Actors.containsAll(terminated[w]!!) }) {
            "Invariant 'TerminatedBounded' violated"
        }
        // TLA+ invariant: DeadNotWatching
        check(Actors.all { a -> (!(a !in alive)) || (watching[a]!! == setOf()) }) {
            "Invariant 'DeadNotWatching' violated"
        }
    }


    // ── Operations (from TLA+ actions) ─────────────────────────────

    /**
     * TLA+ action: Watch
     * - Watch: TLA+ action: Watch
     */
    @Operation
    fun watch(@Param(name = "w") w: Int, target: Int): String = synchronized(lockObj) {
        if (((w != target) && (w in alive)) && (target !in watching[w]!!)) {
            watchers[target] = watchers[target]!!.add(w)
            watching[w] = watching[w]!!.add(target)
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: Unwatch
     * - Unwatch: TLA+ action: Unwatch
     */
    @Operation
    fun unwatch(@Param(name = "w") w: Int, target: Int): String = synchronized(lockObj) {
        if ((w in alive) && (target in watching[w]!!)) {
            watchers[target] = watchers[target]!!.remove(w)
            watching[w] = watching[w]!!.remove(target)
            checkInvariants()
            return "ok"
        }
        return "noop"
    }


    /**
     * TLA+ action: Die
     * - Die: TLA+ action: Die
     */
    @Operation
    fun die(@Param(name = "a") a: Int): String = synchronized(lockObj) {
        if (a in alive) {
            alive.remove(a)
            terminated = mutableMapOf()
            watchers = mutableMapOf()
            watching[a] = {}
            checkInvariants()
            return "ok"
        }
        return "noop"
    }



    // ── Lincheck test methods ──────────────────────────────────────

    /**
     * MODEL CHECKING MODE: Exhaustively explores ALL possible thread
     * interleavings.  If any interleaving produces a non-linearizable
     * result or violates an invariant, Lincheck reports the exact trace.
     */
    @Test
    fun modelCheckingTest() = ModelCheckingOptions()
        .threads(3)
        .actorsPerThread(2)
        .invocationsPerIteration(1000)
        .iterations(50)
        .checkObstructionFreedom(false)
        .actorsBefore(0)
        .actorsAfter(0)
        .check(this::class)

    /**
     * STRESS TEST MODE: Runs under real concurrent load.
     * Catches JVM-specific issues that model checking may miss.
     */
    @Test
    fun stressTest() = StressOptions()
        .threads(3)
        .actorsPerThread(2)
        .invocationsPerIteration(100)
        .iterations(25)
        .actorsBefore(0)
        .actorsAfter(0)
        .check(this::class)


}
